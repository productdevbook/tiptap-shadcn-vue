{
  "name": "tiptap",
  "type": "registry:ui",
  "dependencies": [
    "@iconify/vue",
    "reka-ui",
    "@vueuse/core"
  ],
  "registryDependencies": [
    "utils",
    "https://tiptap-shadcn-vue.pages.dev/r/button.json",
    "https://tiptap-shadcn-vue.pages.dev/r/label.json",
    "https://tiptap-shadcn-vue.pages.dev/r/textarea.json",
    "https://tiptap-shadcn-vue.pages.dev/r/badge.json",
    "https://tiptap-shadcn-vue.pages.dev/r/dialog.json",
    "https://tiptap-shadcn-vue.pages.dev/r/input.json",
    "https://tiptap-shadcn-vue.pages.dev/r/separator.json",
    "https://tiptap-shadcn-vue.pages.dev/r/tooltip.json"
  ],
  "files": [
    {
      "path": "ui/tiptap/TiptapContent.vue",
      "content": "<script setup lang=\"ts\">\nimport type { Editor } from '@tiptap/vue-3'\nimport type { HTMLAttributes } from 'vue'\nimport { cn } from '@/lib/utils'\nimport { computed, onMounted, ref, watch } from 'vue'\nimport { useTiptapContext } from '.'\n\nconst props = defineProps<{\n  editor?: Editor | null\n  class?: HTMLAttributes['class']\n  placeholder?: string\n}>()\n\n// Get editor from context if not provided directly\nconst { editor: contextEditor } = useTiptapContext()\nconst editor = computed(() => props.editor ?? contextEditor.value)\n\n// Editor is ready when it's available and initialized\nconst isEditorReady = computed(() => {\n  return editor.value && editor.value.isEditable\n})\n\n// Reference to the editor element\nconst editorElement = ref<HTMLElement | null>(null)\n\n// Mount editor to DOM when editor is available or element changes\nwatch([editor, editorElement], ([currentEditor, element]) => {\n  if (currentEditor && element && !element.firstChild) {\n    // If editor is ready but not yet mounted to this element\n    element.append(currentEditor.view.dom)\n  }\n}, { immediate: true })\n\n// Also mount on component mount in case both are already available\nonMounted(() => {\n  if (isEditorReady.value && editorElement.value && !editorElement.value.firstChild) {\n    editorElement.value.append(editor.value!.view.dom)\n  }\n\n  if (isEditorReady.value && editorElement.value && editorElement.value.firstChild) {\n    // Add appropriate ARIA attributes\n    const editorDOM = editorElement.value.firstChild as HTMLElement\n    editorDOM.setAttribute('role', 'textbox')\n    editorDOM.setAttribute('aria-multiline', 'true')\n    editorDOM.setAttribute('aria-label', 'Rich text editor')\n\n    // Add content description for screen readers\n    const srDescription = document.createElement('span')\n    srDescription.className = 'sr-only'\n    srDescription.textContent = 'Use keyboard shortcuts like Ctrl+B for bold, Ctrl+I for italic. Press Alt+F10 for the toolbar.'\n    editorElement.value.appendChild(srDescription)\n  }\n})\n</script>\n\n<template>\n  <div\n    :class=\"cn(\n      'tiptap-editor-wrapper relative',\n      props.class,\n    )\"\n    data-slot=\"tiptap-content\"\n    aria-label=\"Rich text editor\"\n  >\n    <div\n      v-if=\"isEditorReady\"\n      ref=\"editorElement\"\n      class=\"prose prose-sm sm:prose lg:prose-lg xl:prose-xl dark:prose-invert h-full w-full focus:outline-none max-w-none px-4 py-6\"\n      role=\"region\"\n    />\n\n    <div\n      v-else\n      class=\"tiptap-editor-placeholder h-full w-full flex items-center justify-center text-muted-foreground text-sm italic\"\n      aria-live=\"polite\"\n    >\n      {{ placeholder || 'Loading editor...' }}\n    </div>\n  </div>\n</template>\n\n<style>\n/* Editor styles */\n.tiptap-editor-wrapper .ProseMirror {\n  min-height: 100px;\n  height: 100%;\n  border: none;\n  outline: none;\n}\n\n.tiptap-editor-wrapper .ProseMirror p.is-editor-empty:first-child::before {\n  color: #adb5bd;\n  content: attr(data-placeholder);\n  float: left;\n  height: 0;\n  pointer-events: none;\n}\n\n/* Component styles */\n.tiptap-editor-wrapper .component-node {\n  margin-top: 1rem;\n  margin-bottom: 1rem;\n}\n\n.tiptap-editor-wrapper .component-selected {\n  outline: 2px solid #3b82f6;\n  outline-offset: 2px;\n}\n\n/* Heading styles */\n.tiptap-editor-wrapper h1 {\n  font-size: 2em;\n  margin-top: 0.67em;\n  margin-bottom: 0.67em;\n}\n\n.tiptap-editor-wrapper h2 {\n  font-size: 1.5em;\n  margin-top: 0.83em;\n  margin-bottom: 0.83em;\n}\n\n.tiptap-editor-wrapper h3 {\n  font-size: 1.17em;\n  margin-top: 1em;\n  margin-bottom: 1em;\n}\n\n/* Node selection styles */\n.tiptap-editor-wrapper .ProseMirror .is-node-selected {\n  outline: 2px solid #3b82f6;\n  outline-offset: 2px;\n}\n\n/* Placeholder for empty nodes */\n.tiptap-editor-wrapper .ProseMirror p.is-empty::before {\n  color: #adb5bd;\n  content: attr(data-placeholder);\n  float: left;\n  height: 0;\n  pointer-events: none;\n}\n\n/* Focus indicators for accessibility */\n.tiptap-editor-wrapper .ProseMirror:focus-visible {\n  outline: 2px solid hsl(var(--primary));\n  outline-offset: 2px;\n}\n\n/* Better focus styles for interactive elements */\n.tiptap-editor-wrapper .ProseMirror *[data-interactive]:focus-visible {\n  outline: 2px solid hsl(var(--primary));\n  outline-offset: 2px;\n}\n\n/* High contrast mode support */\n@media (forced-colors: active) {\n  .tiptap-editor-wrapper .ProseMirror:focus-visible {\n    outline: 3px solid CanvasText;\n  }\n\n  .tiptap-editor-wrapper .component-selected {\n    outline: 3px solid Highlight;\n  }\n}\n</style>\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/tiptap/TiptapEditor.vue",
      "content": "<script setup lang=\"ts\">\nimport type { Editor } from '@tiptap/vue-3'\nimport type { HTMLAttributes } from 'vue'\nimport { cn } from '@/lib/utils'\nimport { computed } from 'vue'\nimport { useTiptapContext } from '.'\n\nconst props = defineProps<{\n  editor: Editor | null\n  class?: HTMLAttributes['class']\n  fullScreen?: boolean\n}>()\n\n// Try to use the existing context from a parent TiptapProvider\nlet editorContext\ntry {\n  editorContext = useTiptapContext()\n}\ncatch (e) {\n  // No provider found, this editor will manage its own state\n  editorContext = null\n}\n\n// If there's a provider context, we'll use that\n// Otherwise we'll render our own provider\nconst useExternalProvider = computed(() => !!editorContext)\n</script>\n\n<template>\n  <div\n    :class=\"cn(\n      'tiptap-editor',\n      props.fullScreen && 'fixed inset-0 z-50',\n      props.class,\n    )\"\n    data-slot=\"tiptap-editor\"\n  >\n    <TiptapProvider v-if=\"!useExternalProvider\" :editor=\"props.editor\">\n      <slot />\n    </TiptapProvider>\n    <template v-else>\n      <slot />\n    </template>\n  </div>\n</template>\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/tiptap/TiptapIcon.vue",
      "content": "<script lang=\"ts\">\n</script>\n\n<script setup lang=\"ts\">\nimport type { HTMLAttributes } from 'vue'\nimport { cn } from '@/lib/utils'\nimport { Icon } from '@iconify/vue'\nimport { computed } from 'vue'\n\nconst props = defineProps<{\n  name: keyof typeof icons | (string & {})\n  size?: 'sm' | 'md' | 'lg'\n  class?: HTMLAttributes['class']\n}>()\n\nconst icons = {\n  Bold: 'lucide:bold',\n  LoaderCircle: 'lucide:loader-circle',\n  Italic: 'lucide:italic',\n  Underline: 'lucide:underline',\n  Quote: 'lucide:quote',\n  TextQuote: 'lucide:text-quote',\n  Strikethrough: 'lucide:strikethrough',\n  Minus: 'lucide:minus',\n  Eraser: 'lucide:eraser',\n  PaintRoller: 'lucide:paint-roller',\n  Redo2: 'lucide:redo-2',\n  Undo2: 'lucide:undo-2',\n  AlignCenter: 'radix-icons:text-align-center',\n  AlignJustify: 'radix-icons:text-align-justify',\n  AlignLeft: 'radix-icons:text-align-left',\n  AlignRight: 'radix-icons:text-align-right',\n  ChevronUp: 'lucide:chevron-up',\n  ChevronDown: 'lucide:chevron-down',\n  Subscript: 'lucide:subscript',\n  Superscript: 'lucide:superscript',\n  Code: 'lucide:code',\n  Code2: 'lucide:code-2',\n  Type: 'lucide:type',\n  IndentIncrease: 'lucide:indent-increase',\n  IndentDecrease: 'lucide:indent-decrease',\n  List: 'lucide:list',\n  ListOrdered: 'lucide:list-ordered',\n  ListTodo: 'lucide:list-todo',\n  Link: 'lucide:link',\n  ImageUp: 'lucide:image-up',\n  Video: 'lucide:video',\n  Maximize: 'lucide:maximize',\n  Minimize: 'lucide:minimize',\n  Table: 'lucide:table',\n  Sparkles: 'lucide:sparkles',\n  Magic: 'mdi:magic',\n  Pencil: 'lucide:pencil',\n  Unlink: 'lucide:unlink',\n  BetweenHorizonalEnd: 'lucide:between-horizontal-end',\n  BetweenHorizonalStart: 'lucide:between-horizontal-start',\n  ColumnDelete: 'hugeicons:column-delete',\n  BetweenVerticalStart: 'lucide:between-vertical-start',\n  BetweenVerticalEnd: 'lucide:between-vertical-end',\n  RowDelete: 'hugeicons:row-delete',\n  TableCellsMerge: 'lucide:table-cells-merge',\n  TableCellsSplit: 'lucide:table-cells-split',\n  Trash2: 'lucide:trash-2',\n  Trash: 'lucide:trash',\n  Replace: 'lucide:replace',\n  ChevronsUpDown: 'lucide:chevrons-up-down',\n  LineHeight: 'mdi:format-line-height',\n  Word: 'mdi:file-word-outline',\n  Paragraph: 'ci:text',\n  Heading1: 'lucide:heading-1',\n  Heading2: 'lucide:heading-2',\n  Heading3: 'lucide:heading-3',\n  Columns2: 'lucide:columns-2',\n  Columns3: 'lucide:columns-3',\n  Columns4: 'lucide:columns-4',\n  Plus: 'lucide:plus',\n  Grip: 'lucide:grip-vertical',\n  Copy: 'lucide:copy',\n  Clipboard: 'lucide:clipboard',\n  MenuDown: 'icon-park-solid:down-one',\n  SizeS: 'mdi:size-s',\n  SizeM: 'mdi:size-m',\n  SizeL: 'mdi:size-l',\n  AspectRatio: 'mdi:aspect-ratio',\n  Gaode: 'echo-gaode',\n  Baidu: 'echo-baidu',\n  Youku: 'echo-youku',\n  BiliBili: 'echo-bilibili',\n  Modao: 'echo-modao',\n  Lanhu: 'echo-lanhu',\n  QQVideo: 'echo-qqvideo',\n  Figma: 'echo-figma',\n  Canva: 'echo-canva',\n  Processon: 'echo-processon',\n  Codepen: 'echo-codepen',\n  Jinshuju: 'echo-jinshuju',\n  PanelLeft: 'lucide:panel-left',\n  PanelRight: 'lucide:panel-right',\n  Columns: 'lucide:columns',\n  AI: 'meteocons:star-fill',\n  ChevronRight: 'lucide:chevron-right',\n  ArrowUp: 'lucide:arrow-up',\n  Paste: 'lucide:clipboard-paste',\n  Cut: 'lucide:scissors',\n  File: 'lucide:file',\n  Refresh: 'lucide:refresh-ccw',\n  Eye: 'lucide:eye',\n  Printer: 'lucide:printer',\n  Tablet: 'lucide:tablet',\n  Phone: 'lucide:smartphone',\n  Monitor: 'lucide:monitor',\n  TextSelect: 'lucide:text-select',\n  SpellCheck: 'lucide:spell-check-2',\n  DocSearch: 'lucide:text-search',\n  Close: 'lucide:x',\n  ImageSize: 'fluent:resize-image-24-filled',\n  FlipVertical: 'lucide:flip-vertical',\n  FlipHorizontal: 'lucide:flip-horizontal',\n  WrapText: 'lucide:wrap-text',\n}\n\n// Resolve the icon name\nconst iconName = computed(() => (icons as any)[props.name] as string || props.name)\n\n// Compute size classes\nconst sizeClasses = computed(() => {\n  switch (props.size) {\n    case 'sm': return 'h-4 w-4'\n    case 'lg': return 'h-6 w-6'\n    default: return 'h-5 w-5'\n  }\n})\n\n// Log a warning if the icon is not found\nif (!iconName.value) {\n  console.error(`Icon ${props.name} not found`)\n}\n</script>\n\n<template>\n  <Icon\n    :icon=\"iconName\"\n    :class=\"cn(\n      sizeClasses,\n      props.class,\n    )\"\n    data-slot=\"tiptap-icon\"\n  />\n</template>\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/tiptap/TiptapKeyboardShortcuts.vue",
      "content": "<script setup lang=\"ts\">\nimport type { HTMLAttributes } from 'vue'\nimport { cn } from '@/lib/utils'\nimport { shortcuts } from './tiptapTreeUtils'\n\nconst props = defineProps<{\n  class?: HTMLAttributes['class']\n}>()\n</script>\n\n<template>\n  <div\n    :class=\"cn('tiptap-keyboard-shortcuts p-4', props.class)\"\n    data-slot=\"tiptap-keyboard-shortcuts\"\n  >\n    <h3 class=\"text-lg font-medium mb-2\">\n      Keyboard Shortcuts\n    </h3>\n    <div class=\"grid gap-2\">\n      <div v-for=\"(shortcut, index) in shortcuts\" :key=\"index\" class=\"flex items-center justify-between\">\n        <div class=\"flex gap-1\">\n          <kbd\n            v-for=\"(key, kIndex) in shortcut.keys\"\n            :key=\"kIndex\"\n            class=\"px-2 py-1 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg dark:bg-gray-600 dark:text-gray-100 dark:border-gray-500\"\n          >\n            {{ key }}\n          </kbd>\n        </div>\n        <span class=\"text-sm text-muted-foreground\">{{ shortcut.description }}</span>\n      </div>\n    </div>\n  </div>\n</template>\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/tiptap/TiptapMobileToolbar.vue",
      "content": "<script setup lang=\"ts\">\nimport type { Editor } from '@tiptap/vue-3'\nimport type { HTMLAttributes } from 'vue'\nimport { Button } from '@/components/ui/button'\nimport { cn } from '@/lib/utils'\nimport { computed, ref } from 'vue'\nimport { useTiptapContext } from '.'\nimport Icon from './TiptapIcon.vue'\n\nconst props = defineProps<{\n  editor?: Editor | null\n  class?: HTMLAttributes['class']\n}>()\n\n// Get editor from context if not provided directly\nconst { editor: contextEditor } = useTiptapContext()\nconst editor = computed(() => props.editor ?? contextEditor.value)\n\n// Check if editor is ready\nconst isEditorReady = computed(() => {\n  return editor.value && editor.value.isEditable\n})\n\n// Active formatting menu\nconst activeMenu = ref<'text' | 'paragraph' | 'list' | 'insert' | null>(null)\n\n// Toggle active menu\nfunction toggleMenu(menu: 'text' | 'paragraph' | 'list' | 'insert') {\n  if (activeMenu.value === menu) {\n    activeMenu.value = null\n  }\n  else {\n    activeMenu.value = menu\n  }\n}\n\n// Check if the current selection has an active mark\nfunction isActive(type: string, attributes = {}) {\n  if (!isEditorReady.value)\n    return false\n\n  return editor.value!.isActive(type, attributes)\n}\n</script>\n\n<template>\n  <div\n    :class=\"cn(\n      'tiptap-mobile-toolbar fixed bottom-0 left-0 right-0 bg-background border-t z-50',\n      props.class,\n    )\"\n    data-slot=\"tiptap-mobile-toolbar\"\n  >\n    <!-- Main toolbar buttons -->\n    <div class=\"flex items-center justify-around p-2\">\n      <Button\n        size=\"sm\"\n        variant=\"ghost\"\n        :class=\"{ 'bg-accent': activeMenu === 'text' }\"\n        @click=\"toggleMenu('text')\"\n      >\n        <Icon name=\"mdi:format-bold\" class=\"h-5 w-5\" />\n        <span class=\"ml-1 text-xs\">Text</span>\n      </Button>\n\n      <Button\n        size=\"sm\"\n        variant=\"ghost\"\n        :class=\"{ 'bg-accent': activeMenu === 'paragraph' }\"\n        @click=\"toggleMenu('paragraph')\"\n      >\n        <Icon name=\"mdi:format-paragraph\" class=\"h-5 w-5\" />\n        <span class=\"ml-1 text-xs\">Style</span>\n      </Button>\n\n      <Button\n        size=\"sm\"\n        variant=\"ghost\"\n        :class=\"{ 'bg-accent': activeMenu === 'list' }\"\n        @click=\"toggleMenu('list')\"\n      >\n        <Icon name=\"mdi:format-list-bulleted\" class=\"h-5 w-5\" />\n        <span class=\"ml-1 text-xs\">List</span>\n      </Button>\n\n      <Button\n        size=\"sm\"\n        variant=\"ghost\"\n        :class=\"{ 'bg-accent': activeMenu === 'insert' }\"\n        @click=\"toggleMenu('insert')\"\n      >\n        <Icon name=\"mdi:plus\" class=\"h-5 w-5\" />\n        <span class=\"ml-1 text-xs\">Insert</span>\n      </Button>\n    </div>\n\n    <!-- Expandable submenus -->\n    <div v-if=\"activeMenu\" class=\"border-t p-2 flex overflow-x-auto gap-1 pb-safe\">\n      <!-- Text formatting submenu -->\n      <template v-if=\"activeMenu === 'text'\">\n        <Button\n          size=\"icon\"\n          variant=\"ghost\"\n          :class=\"{ 'bg-accent': isActive('bold') }\"\n          :disabled=\"!isEditorReady\"\n          @click=\"editor?.chain().focus().toggleBold().run()\"\n        >\n          <Icon name=\"mdi:format-bold\" class=\"h-5 w-5\" />\n        </Button>\n\n        <Button\n          size=\"icon\"\n          variant=\"ghost\"\n          :class=\"{ 'bg-accent': isActive('italic') }\"\n          :disabled=\"!isEditorReady\"\n          @click=\"editor?.chain().focus().toggleItalic().run()\"\n        >\n          <Icon name=\"mdi:format-italic\" class=\"h-5 w-5\" />\n        </Button>\n\n        <Button\n          size=\"icon\"\n          variant=\"ghost\"\n          :class=\"{ 'bg-accent': isActive('strike') }\"\n          :disabled=\"!isEditorReady\"\n          @click=\"editor?.chain().focus().toggleStrike().run()\"\n        >\n          <Icon name=\"mdi:format-strikethrough\" class=\"h-5 w-5\" />\n        </Button>\n\n        <Button\n          size=\"icon\"\n          variant=\"ghost\"\n          :class=\"{ 'bg-accent': isActive('code') }\"\n          :disabled=\"!isEditorReady\"\n          @click=\"editor?.chain().focus().toggleCode().run()\"\n        >\n          <Icon name=\"mdi:code-tags\" class=\"h-5 w-5\" />\n        </Button>\n      </template>\n\n      <!-- Paragraph styles submenu -->\n      <template v-if=\"activeMenu === 'paragraph'\">\n        <Button\n          size=\"icon\"\n          variant=\"ghost\"\n          :class=\"{ 'bg-accent': isActive('paragraph') }\"\n          :disabled=\"!isEditorReady\"\n          @click=\"editor?.chain().focus().setParagraph().run()\"\n        >\n          <Icon name=\"mdi:format-paragraph\" class=\"h-5 w-5\" />\n        </Button>\n\n        <Button\n          size=\"icon\"\n          variant=\"ghost\"\n          :class=\"{ 'bg-accent': isActive('heading', { level: 1 }) }\"\n          :disabled=\"!isEditorReady\"\n          @click=\"editor?.chain().focus().toggleHeading({ level: 1 }).run()\"\n        >\n          <Icon name=\"mdi:format-header-1\" class=\"h-5 w-5\" />\n        </Button>\n\n        <Button\n          size=\"icon\"\n          variant=\"ghost\"\n          :class=\"{ 'bg-accent': isActive('heading', { level: 2 }) }\"\n          :disabled=\"!isEditorReady\"\n          @click=\"editor?.chain().focus().toggleHeading({ level: 2 }).run()\"\n        >\n          <Icon name=\"mdi:format-header-2\" class=\"h-5 w-5\" />\n        </Button>\n\n        <Button\n          size=\"icon\"\n          variant=\"ghost\"\n          :class=\"{ 'bg-accent': isActive('blockquote') }\"\n          :disabled=\"!isEditorReady\"\n          @click=\"editor?.chain().focus().toggleBlockquote().run()\"\n        >\n          <Icon name=\"mdi:format-quote-close\" class=\"h-5 w-5\" />\n        </Button>\n\n        <Button\n          size=\"icon\"\n          variant=\"ghost\"\n          :class=\"{ 'bg-accent': isActive('codeBlock') }\"\n          :disabled=\"!isEditorReady\"\n          @click=\"editor?.chain().focus().toggleCodeBlock().run()\"\n        >\n          <Icon name=\"mdi:code-braces\" class=\"h-5 w-5\" />\n        </Button>\n      </template>\n\n      <!-- List styles submenu -->\n      <template v-if=\"activeMenu === 'list'\">\n        <Button\n          size=\"icon\"\n          variant=\"ghost\"\n          :class=\"{ 'bg-accent': isActive('bulletList') }\"\n          :disabled=\"!isEditorReady\"\n          @click=\"editor?.chain().focus().toggleBulletList().run()\"\n        >\n          <Icon name=\"mdi:format-list-bulleted\" class=\"h-5 w-5\" />\n        </Button>\n\n        <Button\n          size=\"icon\"\n          variant=\"ghost\"\n          :class=\"{ 'bg-accent': isActive('orderedList') }\"\n          :disabled=\"!isEditorReady\"\n          @click=\"editor?.chain().focus().toggleOrderedList().run()\"\n        >\n          <Icon name=\"mdi:format-list-numbered\" class=\"h-5 w-5\" />\n        </Button>\n\n        <Button\n          size=\"icon\"\n          variant=\"ghost\"\n          :disabled=\"!editor?.can().sinkListItem('listItem')\"\n          @click=\"editor?.chain().focus().sinkListItem('listItem').run()\"\n        >\n          <Icon name=\"mdi:format-indent-increase\" class=\"h-5 w-5\" />\n        </Button>\n\n        <Button\n          size=\"icon\"\n          variant=\"ghost\"\n          :disabled=\"!editor?.can().liftListItem('listItem')\"\n          @click=\"editor?.chain().focus().liftListItem('listItem').run()\"\n        >\n          <Icon name=\"mdi:format-indent-decrease\" class=\"h-5 w-5\" />\n        </Button>\n      </template>\n\n      <!-- Insert submenu -->\n      <template v-if=\"activeMenu === 'insert'\">\n        <Button\n          size=\"icon\"\n          variant=\"ghost\"\n          :disabled=\"!isEditorReady\"\n          @click=\"editor?.chain().focus().setHorizontalRule().run()\"\n        >\n          <Icon name=\"mdi:minus\" class=\"h-5 w-5\" />\n        </Button>\n\n        <Button\n          size=\"icon\"\n          variant=\"ghost\"\n          :disabled=\"!isEditorReady\"\n          @click=\"$emit('open-component-selector')\"\n        >\n          <Icon name=\"mdi:puzzle-outline\" class=\"h-5 w-5\" />\n        </Button>\n      </template>\n    </div>\n  </div>\n</template>\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/tiptap/TiptapProvider.vue",
      "content": "<script setup lang=\"ts\">\nimport type { Editor } from '@tiptap/vue-3'\nimport { computed, onMounted, ref, watch } from 'vue'\nimport { provideTiptapContext } from '.'\n\nconst props = defineProps<{\n  editor: Editor | undefined\n}>()\n\n// State management for the Tiptap context\nconst sidebarVisible = defineModel('sidebarVisible', { default: true })\nconst selectedNodeId = ref('')\nconst editorNodes = ref([])\nconst content = ref('')\n\n// Update editor nodes when content changes\nfunction updateEditorNodes() {\n  if (!props.editor)\n    return\n\n  // Clear the nodes array when document is empty\n  if (props.editor.isEmpty) {\n    editorNodes.value = []\n    return\n  }\n\n  const nodes = []\n\n  // Process all nodes in the document\n  props.editor.state.doc.descendants((node, pos) => {\n    // Skip text nodes and inline nodes\n    if (node.isText)\n      return\n\n    // Generate a unique ID for the node\n    let nodeId\n    let nodeName\n    let nodeIcon\n    let nodeContent = ''\n    let depth = 0\n\n    if (node.type.name === 'component') {\n      // Handle component nodes specially\n      nodeId = node.attrs.id || `component-${pos}`\n      nodeName = node.attrs.componentName\n      nodeIcon = 'mdi:puzzle-outline' // Default component icon\n      depth = getNodeDepth(pos)\n    }\n    else {\n      // Handle other node types\n      nodeId = `${node.type.name}-${pos}`\n\n      // Get a display name for the node type\n      switch (node.type.name) {\n        case 'paragraph':\n          nodeName = 'Paragraph'\n          nodeIcon = 'mdi:format-paragraph'\n          nodeContent = getTextContentPreview(node)\n          depth = getNodeDepth(pos)\n          break\n        case 'heading':\n          const level = node.attrs.level\n          nodeName = `Heading ${level}`\n          nodeIcon = `mdi:format-header-${level}`\n          nodeContent = getTextContentPreview(node)\n          depth = getNodeDepth(pos)\n          break\n        case 'bulletList':\n          nodeName = 'Bullet List'\n          nodeIcon = 'mdi:format-list-bulleted'\n          depth = getNodeDepth(pos)\n          break\n        case 'orderedList':\n          nodeName = 'Numbered List'\n          nodeIcon = 'mdi:format-list-numbered'\n          depth = getNodeDepth(pos)\n          break\n        case 'listItem':\n          nodeName = 'List Item'\n          nodeIcon = 'mdi:minus-circle-outline'\n          nodeContent = getTextContentPreview(node)\n          depth = getNodeDepth(pos) + 1 // Indent list items\n          break\n        case 'blockquote':\n          nodeName = 'Quote'\n          nodeIcon = 'mdi:format-quote-close'\n          nodeContent = getTextContentPreview(node)\n          depth = getNodeDepth(pos)\n          break\n        case 'horizontalRule':\n          nodeName = 'Divider'\n          nodeIcon = 'mdi:minus'\n          depth = getNodeDepth(pos)\n          break\n        case 'image':\n          nodeName = 'Image'\n          nodeIcon = 'mdi:image'\n          depth = getNodeDepth(pos)\n          break\n        case 'codeBlock':\n          nodeName = 'Code Block'\n          nodeIcon = 'mdi:code-tags'\n          depth = getNodeDepth(pos)\n          break\n        default:\n          nodeName = node.type.name\n          nodeIcon = 'mdi:code-braces'\n          depth = getNodeDepth(pos)\n      }\n    }\n\n    // Only add block-level nodes to the outline\n    if (!node.isInline) {\n      nodes.push({\n        id: nodeId,\n        name: nodeName,\n        type: node.type.name,\n        icon: nodeIcon,\n        content: nodeContent,\n        position: pos,\n        nodeSize: node.nodeSize,\n        selected: nodeId === selectedNodeId.value,\n        depth,\n      })\n    }\n  })\n\n  editorNodes.value = nodes\n}\n\n// Get the text content of a node (for previews)\nfunction getTextContentPreview(node) {\n  let text = ''\n\n  node.descendants((child) => {\n    if (child.isText) {\n      text += child.text\n    }\n  })\n\n  // Limit the preview length\n  if (text.length > 25) {\n    text = `${text.substring(0, 25)}...`\n  }\n\n  return text || 'Empty'\n}\n\n// Get the depth level of a node based on its position\nfunction getNodeDepth(pos) {\n  if (!props.editor)\n    return 0\n\n  let depth = 0\n  const node = props.editor.state.doc.resolve(pos)\n\n  for (let i = 1; i <= node.depth; i++) {\n    const parent = node.node(i)\n    if (!parent.isText && !parent.isInline) {\n      depth++\n    }\n  }\n\n  return depth\n}\n\n// Select node by id\nfunction selectNode(id) {\n  if (!props.editor)\n    return\n\n  selectedNodeId.value = id\n\n  // Find the node in the document and set the selection to it\n  const nodePos = findNodePositionById(id)\n  if (nodePos !== null) {\n    const { from, to } = nodePos\n    props.editor.chain().focus().setNodeSelection(from).run()\n  }\n}\n\n// Find node position by ID\nfunction findNodePositionById(id) {\n  if (!props.editor)\n    return null\n\n  let result = null\n\n  props.editor.state.doc.descendants((node, pos) => {\n    if (node.attrs.id === id || `${node.type.name}-${pos}` === id) {\n      result = { from: pos, to: pos + node.nodeSize }\n      return false // Stop traversal\n    }\n  })\n\n  return result\n}\n\n// Delete a node by id\nfunction deleteNode(id) {\n  if (!props.editor)\n    return\n\n  // Find the node position in the document\n  const nodePos = findNodePositionById(id)\n  if (nodePos === null) {\n    return\n  }\n\n  try {\n    // Create a transaction to delete the node\n    const tr = props.editor.state.tr\n    const { from, to } = nodePos\n\n    // Delete the node from the document\n    tr.delete(from, to)\n\n    // Apply the transaction\n    props.editor.view.dispatch(tr)\n\n    // Update nodes\n    updateEditorNodes()\n\n    // Update selectedNodeId if it was the deleted node\n    if (selectedNodeId.value === id) {\n      selectedNodeId.value = ''\n    }\n\n    return true\n  }\n  catch (error) {\n    console.error('Error deleting node:', error)\n    return false\n  }\n}\n\n// Duplicate a node by id\nfunction duplicateNode(id) {\n  if (!props.editor)\n    return\n\n  // Find the node position in the document\n  const nodePos = findNodePositionById(id)\n  if (nodePos === null) {\n    return false\n  }\n\n  try {\n    const { from, to } = nodePos\n    const slice = props.editor.state.doc.slice(from, to)\n\n    // Create a transaction to insert the copy after the original\n    const tr = props.editor.state.tr\n    tr.insert(to, slice.content)\n\n    // Apply the transaction\n    props.editor.view.dispatch(tr)\n\n    // Update nodes\n    updateEditorNodes()\n\n    return true\n  }\n  catch (error) {\n    console.error('Error duplicating node:', error)\n    return false\n  }\n}\n\n// Reorder nodes in the document\nfunction reorderNodes({ sourceId, targetId, position }: { sourceId: string, targetId: string, position: 'before' | 'after' }) {\n  if (!props.editor)\n    return false\n\n  // Find the source and target node positions\n  const sourcePos = findNodePositionById(sourceId)\n  const targetPos = findNodePositionById(targetId)\n\n  if (!sourcePos || !targetPos) {\n    console.error('Could not find source or target node')\n    return false\n  }\n\n  try {\n    // Save the source node content as a slice\n    const sourceNode = props.editor.state.doc.slice(sourcePos.from, sourcePos.to)\n\n    // Create a transaction that first removes the source node\n    let tr = props.editor.state.tr.delete(sourcePos.from, sourcePos.to)\n\n    // Calculate insertion position based on whether it's before or after the target\n    // Need to adjust position if target is after source (since deleting source shifts positions)\n    let insertPos = position === 'before' ? targetPos.from : targetPos.to\n    if (sourcePos.from < targetPos.from) {\n      // If source was before target, adjust the target position to account for removed content\n      insertPos -= (sourcePos.to - sourcePos.from)\n    }\n\n    // Insert the saved slice at the calculated position\n    tr = tr.insert(insertPos, sourceNode.content)\n\n    // Apply the transaction\n    props.editor.view.dispatch(tr)\n\n    // Update the nodes display\n    updateEditorNodes()\n\n    return true\n  }\n  catch (error) {\n    console.error('Error reordering nodes:', error)\n    return false\n  }\n}\n\n// Toggle sidebar visibility\nfunction toggleSidebar() {\n  sidebarVisible.value = !sidebarVisible.value\n}\n\n// Watch for editor changes\nwatch(() => props.editor?.getHTML(), () => {\n  if (props.editor) {\n    content.value = props.editor.getHTML()\n    updateEditorNodes()\n  }\n}, { immediate: true })\n\n// History management\nconst canUndo = computed(() => props.editor?.can().undo() ?? false)\nconst canRedo = computed(() => props.editor?.can().redo() ?? false)\n\n// Add metadata for the document\nconst metadata = ref({\n  lastSaved: null as Date | null,\n  wordCount: 0,\n  charCount: 0,\n  readingTime: '0 min',\n})\n\n// Update metadata when content changes\nfunction updateMetadata() {\n  if (!props.editor)\n    return\n\n  const text = props.editor.state.doc.textContent\n  metadata.value.charCount = text.length\n  metadata.value.wordCount = text.split(/\\s+/).filter(word => word.length > 0).length\n\n  // Calculate reading time (average reading speed: 200 words per minute)\n  const minutes = Math.max(1, Math.round(metadata.value.wordCount / 200))\n  metadata.value.readingTime = `${minutes} min read`\n}\n\n// Track editor changes with debouncing\nlet updateTimeout: ReturnType<typeof setTimeout> | null = null\nfunction debouncedUpdate() {\n  if (updateTimeout)\n    clearTimeout(updateTimeout)\n  updateTimeout = setTimeout(() => {\n    updateEditorNodes()\n    updateMetadata()\n  }, 250)\n}\n\n// Watch for editor changes with debouncing\nwatch(() => props.editor, (newEditor) => {\n  if (newEditor) {\n    updateEditorNodes()\n    updateMetadata()\n\n    newEditor.on('update', () => {\n      debouncedUpdate()\n    })\n  }\n\n  return () => {\n    if (updateTimeout)\n      clearTimeout(updateTimeout)\n  }\n}, { immediate: true })\n\n// Provide context to child components\nprovideTiptapContext({\n  editor: computed(() => props.editor),\n  editorNodes,\n  sidebarVisible,\n  selectedNodeId,\n  toggleSidebar,\n  selectNode,\n  deleteNode,\n  duplicateNode,\n  reorderNodes, // Add the new method to the context\n  updateEditorNodes,\n  canUndo,\n  canRedo,\n  metadata: computed(() => metadata.value),\n  updateMetadata,\n})\n\n// When the component mounts, initialize\nonMounted(() => {\n  if (props.editor) {\n    updateEditorNodes()\n  }\n})\n</script>\n\n<template>\n  <div data-slot=\"tiptap-provider\">\n    <slot />\n  </div>\n</template>\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/tiptap/TiptapSlotPanel.vue",
      "content": "<script setup lang=\"ts\">\nimport type { Editor } from '@tiptap/vue-3'\nimport type { HTMLAttributes } from 'vue'\nimport { Label } from '@/components/ui/label'\nimport { Textarea } from '@/components/ui/textarea'\nimport { cn } from '@/lib/utils'\nimport { computed, reactive, watch } from 'vue'\nimport { useTiptapContext } from '.'\n\nconst props = defineProps<{\n  editor?: Editor | null\n  componentName?: string\n  componentSlots?: Record<string, string>\n  componentId?: string\n  class?: HTMLAttributes['class']\n}>()\n\nconst emits = defineEmits<{\n  'update:componentSlots': [slots: Record<string, string>]\n}>()\n\n// Get editor from context if not provided directly\nconst { editor: contextEditor } = useTiptapContext()\nconst editor = computed(() => props.editor ?? contextEditor.value)\n\n// Create a reactive object to track current slot values\nconst slotContents = reactive<Record<string, string>>(props.componentSlots || {})\n\n// Update form values when component slots change\nwatch(() => props.componentSlots, (newSlots) => {\n  if (newSlots) {\n    Object.keys(newSlots).forEach((key) => {\n      slotContents[key] = newSlots[key]\n    })\n  }\n}, { deep: true, immediate: true })\n\n// Get component metadata based on component name\nconst componentMeta = computed(() => {\n  // This would typically come from a composable or prop\n  // For now, we'll return a simple mock structure\n  return {\n    name: props.componentName || 'Unknown',\n    slots: [\n      {\n        name: 'default',\n        description: 'Default content slot',\n      },\n      {\n        name: 'icon',\n        description: 'Icon content',\n      },\n      {\n        name: 'description',\n        description: 'Additional description text',\n      },\n    ],\n  }\n})\n\n// Handle slot content updates\nfunction updateSlotContent(slotName: string, content: string) {\n  slotContents[slotName] = content\n  emits('update:componentSlots', { ...slotContents })\n\n  // If editor and componentId are available, update the node\n  if (editor.value && props.componentId) {\n    editor.value.chain().focus().updateComponentSlots(props.componentId, { ...slotContents }).run()\n  }\n}\n</script>\n\n<template>\n  <div\n    :class=\"cn(\n      'tiptap-slot-panel',\n      props.class,\n    )\"\n    data-slot=\"tiptap-slot-panel\"\n  >\n    <div class=\"space-y-4\">\n      <h3 class=\"text-sm font-medium\">\n        {{ componentName || componentMeta.name }} Slots\n      </h3>\n\n      <div class=\"space-y-6\">\n        <div\n          v-for=\"slot in componentMeta.slots\"\n          :key=\"slot.name\"\n          class=\"space-y-2\"\n        >\n          <div class=\"flex justify-between items-baseline\">\n            <Label :for=\"`slot-${slot.name}`\">{{ slot.name }}</Label>\n          </div>\n\n          <Textarea\n            :id=\"`slot-${slot.name}`\"\n            :value=\"slotContents[slot.name] || ''\"\n            :placeholder=\"slot.description || `Content for ${slot.name} slot`\"\n            rows=\"4\"\n            class=\"resize-y min-h-[100px]\"\n            @input=\"updateSlotContent(slot.name, $event.target.value)\"\n          />\n\n          <p v-if=\"slot.description\" class=\"text-xs text-muted-foreground\">\n            {{ slot.description }}\n          </p>\n\n          <div class=\"text-xs text-muted-foreground\">\n            <p>You can use HTML in slots. Examples:</p>\n            <pre class=\"bg-muted p-1 rounded mt-1\">&lt;p&gt;Text content&lt;/p&gt;</pre>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/tiptap/TiptapStatusBar.vue",
      "content": "<script setup lang=\"ts\">\nimport type { Editor } from '@tiptap/vue-3'\nimport type { HTMLAttributes } from 'vue'\nimport { Badge } from '@/components/ui/badge'\nimport { cn } from '@/lib/utils'\nimport { computed, ref, watch } from 'vue'\nimport { useTiptapContext } from '.'\n\nconst props = defineProps<{\n  editor?: Editor | null\n  class?: HTMLAttributes['class']\n  showWordCount?: boolean\n  showCharCount?: boolean\n  showSelection?: boolean\n}>()\n\n// Get editor from context if not provided directly\nconst { editor: contextEditor } = useTiptapContext()\nconst editor = computed(() => props.editor ?? contextEditor.value)\n\n// Editor is ready when it's available and initialized\nconst isEditorReady = computed(() => {\n  return editor.value && editor.value.isEditable\n})\n\n// Calculate word and character count\nconst wordCount = ref(0)\nconst charCount = ref(0)\nconst selection = ref({ from: 0, to: 0, text: '' })\n\n// Update counts based on editor content\nfunction updateCounts() {\n  if (!isEditorReady.value)\n    return\n\n  const text = editor.value!.state.doc.textContent\n  charCount.value = text.length\n  wordCount.value = text.split(/\\s+/).filter(word => word.length > 0).length\n\n  // Get selection info\n  const { from, to } = editor.value!.state.selection\n  selection.value = {\n    from,\n    to,\n    text: editor.value!.state.doc.textBetween(from, to, ' '),\n  }\n}\n\n// Watch for editor changes and update counts\nwatch(() => editor.value, (newEditor) => {\n  if (newEditor) {\n    updateCounts()\n\n    // Set up transaction handler for real-time updates\n    newEditor.on('transaction', () => {\n      updateCounts()\n    })\n  }\n}, { immediate: true })\n</script>\n\n<template>\n  <div\n    :class=\"cn(\n      'tiptap-status-bar flex items-center justify-between px-3 py-1 text-xs',\n      props.class,\n    )\"\n    data-slot=\"tiptap-status-bar\"\n  >\n    <!-- Document stats -->\n    <div class=\"flex items-center gap-3\">\n      <span v-if=\"props.showWordCount\" class=\"text-muted-foreground\">\n        {{ wordCount }} words\n      </span>\n      <span v-if=\"props.showCharCount\" class=\"text-muted-foreground\">\n        {{ charCount }} characters\n      </span>\n    </div>\n\n    <!-- Selection info -->\n    <div v-if=\"props.showSelection && selection.from !== selection.to\" class=\"text-muted-foreground\">\n      {{ selection.to - selection.from }} characters selected\n    </div>\n\n    <!-- Editor mode -->\n    <div class=\"flex items-center gap-2\">\n      <Badge v-if=\"isEditorReady\" variant=\"outline\">\n        {{ editor?.isEditable ? 'Editing' : 'Reading' }}\n      </Badge>\n    </div>\n  </div>\n</template>\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/tiptap/TiptapTableToolbar.vue",
      "content": "<script setup lang=\"ts\">\nimport type { Editor } from '@tiptap/vue-3'\nimport type { HTMLAttributes } from 'vue'\nimport { Button } from '@/components/ui/button'\nimport {\n  Dialog,\n  DialogContent,\n  DialogDescription,\n  DialogFooter,\n  DialogHeader,\n  DialogTitle,\n} from '@/components/ui/dialog'\nimport { Input } from '@/components/ui/input'\nimport { Label } from '@/components/ui/label'\nimport { Separator } from '@/components/ui/separator'\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from '@/components/ui/tooltip'\nimport { cn } from '@/lib/utils'\nimport { computed, ref } from 'vue'\nimport { useTiptapContext } from '.'\nimport Icon from './TiptapIcon.vue'\n\nconst props = defineProps<{\n  editor?: Editor | null\n  class?: HTMLAttributes['class']\n}>()\n\n// Get editor from context if not provided directly\nconst { editor: contextEditor } = useTiptapContext()\nconst editor = computed(() => props.editor ?? contextEditor.value)\n\n// Check if editor is ready and focused on a table\nconst isEditorReady = computed(() => editor.value && editor.value.isEditable)\nconst isTableSelected = computed(() =>\n  isEditorReady.value\n  && (editor.value!.isActive('table')\n    || editor.value!.isActive('tableRow')\n    || editor.value!.isActive('tableCell')\n    || editor.value!.isActive('tableHeader')),\n)\n\n// Create new table dialog\nconst showCreateTableDialog = ref(false)\nconst newTableRows = ref(3)\nconst newTableCols = ref(3)\n\n// Create new table\nfunction createTable() {\n  if (!isEditorReady.value)\n    return\n\n  editor.value!.chain().focus().insertTable({ rows: newTableRows.value, cols: newTableCols.value, withHeaderRow: true }).run()\n\n  showCreateTableDialog.value = false\n}\n</script>\n\n<template>\n  <div\n    :class=\"cn(\n      'tiptap-table-toolbar flex flex-wrap gap-1 items-center',\n      props.class,\n    )\"\n    data-slot=\"tiptap-table-toolbar\"\n  >\n    <!-- Table creation -->\n    <TooltipProvider>\n      <Tooltip>\n        <TooltipTrigger as-child>\n          <Button\n            variant=\"outline\"\n            size=\"sm\"\n            :disabled=\"!isEditorReady\"\n            @click=\"showCreateTableDialog = true\"\n          >\n            <Icon name=\"mdi:table\" class=\"h-4 w-4 mr-2\" />\n            Insert Table\n          </Button>\n        </TooltipTrigger>\n        <TooltipContent>Insert a new table</TooltipContent>\n      </Tooltip>\n    </TooltipProvider>\n\n    <!-- Table manipulation (only shown when a table is selected) -->\n    <div v-if=\"isTableSelected\" class=\"flex items-center gap-1\">\n      <TooltipProvider>\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :disabled=\"!isEditorReady\"\n              @click=\"editor?.chain().focus().addColumnBefore().run()\"\n            >\n              <Icon name=\"mdi:table-column-plus-before\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Add column before</TooltipContent>\n        </Tooltip>\n\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :disabled=\"!isEditorReady\"\n              @click=\"editor?.chain().focus().addColumnAfter().run()\"\n            >\n              <Icon name=\"mdi:table-column-plus-after\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Add column after</TooltipContent>\n        </Tooltip>\n\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :disabled=\"!isEditorReady\"\n              @click=\"editor?.chain().focus().deleteColumn().run()\"\n            >\n              <Icon name=\"mdi:table-column-remove\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Delete column</TooltipContent>\n        </Tooltip>\n\n        <Separator orientation=\"vertical\" class=\"h-6\" />\n\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :disabled=\"!isEditorReady\"\n              @click=\"editor?.chain().focus().addRowBefore().run()\"\n            >\n              <Icon name=\"mdi:table-row-plus-before\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Add row before</TooltipContent>\n        </Tooltip>\n\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :disabled=\"!isEditorReady\"\n              @click=\"editor?.chain().focus().addRowAfter().run()\"\n            >\n              <Icon name=\"mdi:table-row-plus-after\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Add row after</TooltipContent>\n        </Tooltip>\n\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :disabled=\"!isEditorReady\"\n              @click=\"editor?.chain().focus().deleteRow().run()\"\n            >\n              <Icon name=\"mdi:table-row-remove\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Delete row</TooltipContent>\n        </Tooltip>\n\n        <Separator orientation=\"vertical\" class=\"h-6\" />\n\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :disabled=\"!isEditorReady\"\n              @click=\"editor?.chain().focus().toggleHeaderCell().run()\"\n            >\n              <Icon name=\"mdi:format-header-pound\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Toggle header cell</TooltipContent>\n        </Tooltip>\n\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :disabled=\"!isEditorReady\"\n              @click=\"editor?.chain().focus().mergeOrSplit().run()\"\n            >\n              <Icon name=\"mdi:table-merge-cells\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Merge or split cells</TooltipContent>\n        </Tooltip>\n\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :disabled=\"!isEditorReady\"\n              class=\"text-destructive hover:bg-destructive/10\"\n              @click=\"editor?.chain().focus().deleteTable().run()\"\n            >\n              <Icon name=\"mdi:table-remove\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Delete table</TooltipContent>\n        </Tooltip>\n      </TooltipProvider>\n    </div>\n\n    <!-- Create table dialog -->\n    <Dialog v-model:open=\"showCreateTableDialog\">\n      <DialogContent>\n        <DialogHeader>\n          <DialogTitle>Insert Table</DialogTitle>\n          <DialogDescription>\n            Choose the size of your new table.\n          </DialogDescription>\n        </DialogHeader>\n\n        <div class=\"grid gap-4 py-4\">\n          <div class=\"grid grid-cols-2 gap-4\">\n            <div class=\"flex flex-col gap-2\">\n              <Label for=\"rows\">Rows</Label>\n              <Input\n                id=\"rows\"\n                v-model=\"newTableRows\"\n                type=\"number\"\n                min=\"1\"\n                max=\"20\"\n              />\n            </div>\n            <div class=\"flex flex-col gap-2\">\n              <Label for=\"columns\">Columns</Label>\n              <Input\n                id=\"columns\"\n                v-model=\"newTableCols\"\n                type=\"number\"\n                min=\"1\"\n                max=\"10\"\n              />\n            </div>\n          </div>\n        </div>\n\n        <DialogFooter>\n          <Button variant=\"outline\" @click=\"showCreateTableDialog = false\">\n            Cancel\n          </Button>\n          <Button @click=\"createTable\">\n            Insert\n          </Button>\n        </DialogFooter>\n      </DialogContent>\n    </Dialog>\n  </div>\n</template>\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/tiptap/TiptapToolbar.vue",
      "content": "<script setup lang=\"ts\">\nimport type { Editor } from '@tiptap/vue-3'\nimport type { HTMLAttributes } from 'vue'\nimport { Button } from '@/components/ui/button'\nimport { Separator } from '@/components/ui/separator'\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from '@/components/ui/tooltip'\nimport { cn } from '@/lib/utils'\nimport { computed } from 'vue'\nimport { useTiptapContext } from '.'\nimport Icon from './TiptapIcon.vue'\n\nconst props = defineProps<{\n  editor?: Editor | null\n  class?: HTMLAttributes['class']\n}>()\n\nconst emits = defineEmits<{}>()\n\n// Get editor from context if not provided directly\nconst { editor: contextEditor } = useTiptapContext()\nconst editor = computed(() => props.editor ?? contextEditor.value)\n\n// Check if editor is ready\nconst isEditorReady = computed(() => {\n  return editor.value && editor.value.isEditable\n})\n\n// Check if the current selection has an active mark\nfunction isActive(type: string, attributes = {}) {\n  if (!isEditorReady.value)\n    return false\n\n  return editor.value!.isActive(type, attributes)\n}\n\n// Character and word count\nconst wordCount = computed(() => {\n  if (!isEditorReady.value)\n    return { characters: 0, words: 0 }\n  const text = editor.value?.state.doc.textContent || ''\n  return {\n    characters: text.length,\n    words: text.split(/\\s+/).filter(word => word.length > 0).length,\n  }\n})\n</script>\n\n<template>\n  <div\n    :class=\"cn(\n      'tiptap-toolbar flex flex-wrap gap-1 items-center',\n      props.class,\n    )\"\n    data-slot=\"tiptap-toolbar\"\n  >\n    <!-- History controls -->\n    <div class=\"flex items-center gap-1\">\n      <TooltipProvider>\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :disabled=\"!editor?.can().undo()\"\n              @click=\"editor?.chain().focus().undo().run()\"\n            >\n              <Icon name=\"mdi:undo\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Undo (Ctrl+Z)</TooltipContent>\n        </Tooltip>\n\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :disabled=\"!editor?.can().redo()\"\n              @click=\"editor?.chain().focus().redo().run()\"\n            >\n              <Icon name=\"mdi:redo\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Redo (Ctrl+Y)</TooltipContent>\n        </Tooltip>\n      </TooltipProvider>\n    </div>\n\n    <Separator orientation=\"vertical\" class=\"h-6\" />\n\n    <!-- Basic Text Formatting -->\n    <div class=\"flex items-center gap-1\">\n      <TooltipProvider>\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :class=\"{ 'bg-accent': isActive('bold') }\"\n              :disabled=\"!isEditorReady\"\n              @click=\"editor?.chain().focus().toggleBold().run()\"\n            >\n              <Icon name=\"mdi:format-bold\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Bold</TooltipContent>\n        </Tooltip>\n\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :class=\"{ 'bg-accent': isActive('italic') }\"\n              :disabled=\"!isEditorReady\"\n              @click=\"editor?.chain().focus().toggleItalic().run()\"\n            >\n              <Icon name=\"mdi:format-italic\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Italic</TooltipContent>\n        </Tooltip>\n\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :class=\"{ 'bg-accent': isActive('strike') }\"\n              :disabled=\"!isEditorReady\"\n              @click=\"editor?.chain().focus().toggleStrike().run()\"\n            >\n              <Icon name=\"mdi:format-strikethrough\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Strike Through</TooltipContent>\n        </Tooltip>\n\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :class=\"{ 'bg-accent': isActive('code') }\"\n              :disabled=\"!isEditorReady\"\n              @click=\"editor?.chain().focus().toggleCode().run()\"\n            >\n              <Icon name=\"mdi:code-tags\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Inline Code</TooltipContent>\n        </Tooltip>\n      </TooltipProvider>\n    </div>\n\n    <Separator orientation=\"vertical\" class=\"h-6\" />\n\n    <!-- Headings -->\n    <div class=\"flex items-center gap-1\">\n      <TooltipProvider>\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :class=\"{ 'bg-accent': isActive('heading', { level: 1 }) }\"\n              :disabled=\"!isEditorReady\"\n              @click=\"editor?.chain().focus().toggleHeading({ level: 1 }).run()\"\n            >\n              <Icon name=\"mdi:format-header-1\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Heading 1</TooltipContent>\n        </Tooltip>\n\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :class=\"{ 'bg-accent': isActive('heading', { level: 2 }) }\"\n              :disabled=\"!isEditorReady\"\n              @click=\"editor?.chain().focus().toggleHeading({ level: 2 }).run()\"\n            >\n              <Icon name=\"mdi:format-header-2\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Heading 2</TooltipContent>\n        </Tooltip>\n\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :class=\"{ 'bg-accent': isActive('heading', { level: 3 }) }\"\n              :disabled=\"!isEditorReady\"\n              @click=\"editor?.chain().focus().toggleHeading({ level: 3 }).run()\"\n            >\n              <Icon name=\"mdi:format-header-3\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Heading 3</TooltipContent>\n        </Tooltip>\n\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :class=\"{ 'bg-accent': isActive('paragraph') }\"\n              :disabled=\"!isEditorReady\"\n              @click=\"editor?.chain().focus().setParagraph().run()\"\n            >\n              <Icon name=\"mdi:format-paragraph\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Paragraph</TooltipContent>\n        </Tooltip>\n      </TooltipProvider>\n    </div>\n\n    <Separator orientation=\"vertical\" class=\"h-6\" />\n\n    <!-- Lists -->\n    <div class=\"flex items-center gap-1\">\n      <TooltipProvider>\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :class=\"{ 'bg-accent': isActive('bulletList') }\"\n              :disabled=\"!isEditorReady\"\n              @click=\"editor?.chain().focus().toggleBulletList().run()\"\n            >\n              <Icon name=\"mdi:format-list-bulleted\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Bullet List</TooltipContent>\n        </Tooltip>\n\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :class=\"{ 'bg-accent': isActive('orderedList') }\"\n              :disabled=\"!isEditorReady\"\n              @click=\"editor?.chain().focus().toggleOrderedList().run()\"\n            >\n              <Icon name=\"mdi:format-list-numbered\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Numbered List</TooltipContent>\n        </Tooltip>\n      </TooltipProvider>\n    </div>\n\n    <Separator orientation=\"vertical\" class=\"h-6\" />\n\n    <!-- Special Elements -->\n    <div class=\"flex items-center gap-1\">\n      <TooltipProvider>\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :class=\"{ 'bg-accent': isActive('blockquote') }\"\n              :disabled=\"!isEditorReady\"\n              @click=\"editor?.chain().focus().toggleBlockquote().run()\"\n            >\n              <Icon name=\"mdi:format-quote-close\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Quote</TooltipContent>\n        </Tooltip>\n\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :disabled=\"!isEditorReady\"\n              @click=\"editor?.chain().focus().setHorizontalRule().run()\"\n            >\n              <Icon name=\"mdi:minus\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Horizontal Divider</TooltipContent>\n        </Tooltip>\n\n        <Tooltip>\n          <TooltipTrigger as-child>\n            <Button\n              size=\"icon\"\n              variant=\"ghost\"\n              :class=\"{ 'bg-accent': isActive('codeBlock') }\"\n              :disabled=\"!isEditorReady\"\n              @click=\"editor?.chain().focus().setCodeBlock().run()\"\n            >\n              <Icon name=\"mdi:code-braces\" class=\"h-5 w-5\" />\n            </Button>\n          </TooltipTrigger>\n          <TooltipContent>Code Block</TooltipContent>\n        </Tooltip>\n      </TooltipProvider>\n    </div>\n\n    <Separator orientation=\"vertical\" class=\"h-6\" />\n\n    <!-- Word count -->\n    <div class=\"ml-auto flex items-center text-xs text-muted-foreground\">\n      <span>{{ wordCount.words }} words</span>\n      <Separator orientation=\"vertical\" class=\"h-4 mx-2\" />\n      <span>{{ wordCount.characters }} characters</span>\n    </div>\n  </div>\n</template>\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/tiptap/TiptapTreeItem.vue",
      "content": "<script setup lang=\"ts\">\nimport type { Instruction } from '@atlaskit/pragmatic-drag-and-drop-hitbox/tree-item'\nimport type { FlattenedItem } from 'reka-ui'\nimport { Button } from '@/components/ui/button'\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from '@/components/ui/tooltip'\nimport { attachInstruction, extractInstruction } from '@atlaskit/pragmatic-drag-and-drop-hitbox/tree-item'\nimport { combine } from '@atlaskit/pragmatic-drag-and-drop/combine'\nimport { draggable, dropTargetForElements, monitorForElements } from '@atlaskit/pragmatic-drag-and-drop/element/adapter'\nimport { pointerOutsideOfPreview } from '@atlaskit/pragmatic-drag-and-drop/element/pointer-outside-of-preview'\nimport { setCustomNativeDragPreview } from '@atlaskit/pragmatic-drag-and-drop/element/set-custom-native-drag-preview'\nimport { unrefElement } from '@vueuse/core'\nimport { TreeItem } from 'reka-ui'\nimport { computed, h, ref, render, watchEffect } from 'vue'\nimport Icon from './TiptapIcon.vue'\n\nconst props = defineProps<{\n  item: FlattenedItem<any>\n}>()\n\nconst emits = defineEmits<{\n  'select-node': [id: string]\n  'duplicate-node': [id: string]\n  'delete-node': [id: string]\n}>()\n\nconst elRef = ref()\nconst isDragging = ref(false)\nconst isDraggedOver = ref(false)\nconst instruction = ref<Extract<Instruction, { type: 'reorder-above' | 'reorder-below' | 'make-child' }> | null>(null)\n\nconst node = computed(() => {\n  return {\n    id: props.item.value.title,\n    name: props.item.value.name,\n    icon: props.item.value.icon || 'mdi:circle',\n    content: props.item.value.content,\n    selected: props.item.value.selected,\n    depth: props.item.value.depth,\n  }\n})\n\nconst mode = computed(() => {\n  if (props.item.hasChildren)\n    return 'expanded'\n  if (props.item.index + 1 === props.item.parentItem?.children?.length)\n    return 'last-in-group'\n  return 'standard'\n})\n\nwatchEffect((onCleanup) => {\n  const currentElement = unrefElement(elRef)\n\n  if (!currentElement)\n    return\n\n  const item = {\n    ...props.item.value,\n    level: props.item.level,\n    id: props.item._id,\n  }\n\n  const dndFunction = combine(\n    draggable({\n      element: currentElement,\n      getInitialData: () => item,\n      onDragStart: () => {\n        isDragging.value = true\n      },\n      onDrop: () => {\n        isDragging.value = false\n      },\n      onGenerateDragPreview({ nativeSetDragImage }) {\n        setCustomNativeDragPreview({\n          getOffset: pointerOutsideOfPreview({ x: '16px', y: '8px' }),\n          render: ({ container }) => {\n            return render(h(\n              'div',\n              { class: 'bg-white text-muted-foreground rounded-md text-sm font-medium px-3 py-1.5 border' },\n              node.value.name || item.id,\n            ), container)\n          },\n          nativeSetDragImage,\n        })\n      },\n    }),\n\n    dropTargetForElements({\n      element: currentElement,\n      getData: ({ input, element }) => {\n        const data = { id: item.id }\n\n        return attachInstruction(data, {\n          input,\n          element,\n          indentPerLevel: 16,\n          currentLevel: props.item.level,\n          mode: mode.value,\n          block: [],\n        })\n      },\n      canDrop: ({ source }) => {\n        return source.data.id !== item.id\n      },\n      onDrag: ({ self }) => {\n        instruction.value = extractInstruction(self.data) as typeof instruction.value\n      },\n      onDragEnter: ({ source }) => {\n        if (source.data.id !== item.id) {\n          isDraggedOver.value = true\n        }\n      },\n      onDragLeave: () => {\n        isDraggedOver.value = false\n        instruction.value = null\n      },\n      onDrop: () => {\n        isDraggedOver.value = false\n        instruction.value = null\n      },\n      getIsSticky: () => true,\n    }),\n\n    monitorForElements({\n      canMonitor: ({ source }) => {\n        return source.data.id !== item.id\n      },\n    }),\n  )\n\n  // Cleanup dnd function\n  onCleanup(() => dndFunction())\n})\n\n// Handle node selection\nfunction handleClick(event) {\n  event.preventDefault()\n  emits('select-node', node.value.id)\n}\n\n// Handle node duplication\nfunction handleDuplicate(event) {\n  event.stopPropagation()\n  emits('duplicate-node', node.value.id)\n}\n\n// Handle node deletion\nfunction handleDelete(event) {\n  event.stopPropagation()\n  emits('delete-node', node.value.id)\n}\n</script>\n\n<template>\n  <TreeItem\n    ref=\"elRef\"\n    :value=\"item.value\"\n    :level=\"item.level\"\n    class=\"outline-node group relative w-full border-none py-2 px-3 rounded-md cursor-pointer\"\n    :class=\"{\n      'opacity-50': isDragging,\n      'bg-accent text-accent-foreground font-medium': node.selected,\n      'hover:bg-accent hover:text-accent-foreground': !node.selected,\n      'text-muted-foreground': !node.selected,\n    }\"\n    @click=\"handleClick\"\n    @select.prevent\n  >\n    <div class=\"flex items-center gap-2 w-full\">\n      <!-- Icon and name -->\n      <div class=\"flex-1 flex items-center gap-2 overflow-hidden\">\n        <Icon :name=\"node.icon\" class=\"h-4 w-4 flex-shrink-0\" />\n        <span class=\"truncate\">{{ node.name }}</span>\n        <span v-if=\"node.content\" class=\"text-xs text-muted-foreground truncate\">\n          {{ node.content }}\n        </span>\n      </div>\n\n      <!-- Actions -->\n      <div class=\"flex items-center gap-1 opacity-0 group-hover:opacity-100\">\n        <TooltipProvider>\n          <Tooltip>\n            <TooltipTrigger as-child>\n              <Button\n                size=\"icon\"\n                variant=\"ghost\"\n                class=\"h-6 w-6\"\n                @click.stop=\"handleDuplicate\"\n              >\n                <Icon name=\"mdi:content-copy\" class=\"h-3.5 w-3.5\" />\n              </Button>\n            </TooltipTrigger>\n            <TooltipContent>Duplicate</TooltipContent>\n          </Tooltip>\n\n          <Tooltip>\n            <TooltipTrigger as-child>\n              <Button\n                size=\"icon\"\n                variant=\"ghost\"\n                class=\"h-6 w-6 text-destructive hover:text-destructive\"\n                @click.stop=\"handleDelete\"\n              >\n                <Icon name=\"mdi:delete\" class=\"h-3.5 w-3.5\" />\n              </Button>\n            </TooltipTrigger>\n            <TooltipContent>Delete</TooltipContent>\n          </Tooltip>\n        </TooltipProvider>\n      </div>\n    </div>\n\n    <!-- Drag indicator -->\n    <div\n      v-if=\"instruction\" class=\"absolute h-full w-full top-0 border-primary\" :style=\"{\n        left: `${instruction?.currentLevel * instruction?.indentPerLevel}px`,\n        width: `calc(100% - ${instruction?.currentLevel * instruction?.indentPerLevel}px)`,\n      }\" :class=\"{\n        '!border-b-2': instruction?.type === 'reorder-below',\n        '!border-t-2': instruction?.type === 'reorder-above',\n        '!border-2 rounded': instruction?.type === 'make-child',\n      }\"\n    />\n  </TreeItem>\n</template>\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/tiptap/TiptapTreeStructure.vue",
      "content": "<script setup lang=\"ts\">\nimport type { HTMLAttributes } from 'vue'\nimport { cn } from '@/lib/utils'\nimport { extractInstruction } from '@atlaskit/pragmatic-drag-and-drop-hitbox/tree-item'\nimport { combine } from '@atlaskit/pragmatic-drag-and-drop/combine'\nimport { monitorForElements } from '@atlaskit/pragmatic-drag-and-drop/element/adapter'\nimport { TreeRoot } from 'reka-ui'\nimport { computed, onBeforeUnmount, watchEffect } from 'vue'\nimport { useTiptapContext } from '.'\nimport TiptapTreeItem from './TiptapTreeItem.vue'\nimport { editorNodesToTree } from './tiptapTreeUtils'\n\nconst props = defineProps<{\n  editorNodes?: any[]\n  class?: HTMLAttributes['class']\n}>()\n\nconst emits = defineEmits<{\n  'select-node': [id: string]\n  'duplicate-node': [id: string]\n  'delete-node': [id: string]\n  'reorder-nodes': [params: { sourceId: string, targetId: string, position: 'before' | 'after' }]\n}>()\n\n// Get context data if props were not provided directly\nconst {\n  editorNodes: contextNodes,\n  selectNode,\n  deleteNode,\n  duplicateNode,\n  reorderNodes,\n} = useTiptapContext()\n\nconst nodes = computed(() => {\n  const rawNodes = props.editorNodes ?? contextNodes.value ?? []\n\n  // Transform nodes to match the tree structure expected by TreeRoot\n  return editorNodesToTree(rawNodes)\n})\n\n// Handle node selection\nfunction handleSelectNode(id: string) {\n  if (selectNode) {\n    selectNode(id)\n  }\n  else {\n    emits('select-node', id)\n  }\n}\n\n// Handle node duplication\nfunction handleDuplicateNode(id: string) {\n  if (duplicateNode) {\n    duplicateNode(id)\n  }\n  else {\n    emits('duplicate-node', id)\n  }\n}\n\n// Handle node deletion\nfunction handleDeleteNode(id: string) {\n  if (deleteNode) {\n    deleteNode(id)\n  }\n  else {\n    emits('delete-node', id)\n  }\n}\n\n// Handle node reordering\nfunction handleReorderNodes(params) {\n  if (reorderNodes) {\n    reorderNodes(params)\n  }\n  else {\n    emits('reorder-nodes', params)\n  }\n}\n\n// Clean up all drag and drop handlers when component is destroyed\nonBeforeUnmount(() => {\n  if (cleanupDnd && typeof cleanupDnd === 'function') {\n    cleanupDnd()\n  }\n})\n\n// Set up global drop monitoring\nlet cleanupDnd: (() => void) | undefined\n\nwatchEffect((onCleanup) => {\n  const dndFunction = combine(\n    monitorForElements({\n      onDrop(args) {\n        const { location, source } = args\n        // didn't drop on anything\n        if (!location.current.dropTargets.length)\n          return\n\n        const sourceId = source.data.id as string\n        const target = location.current.dropTargets[0]\n        const targetId = target.data.id as string\n\n        const instruction = extractInstruction(target.data)\n\n        if (instruction !== null) {\n          if (instruction.type === 'reorder-above') {\n            handleReorderNodes({\n              sourceId,\n              targetId,\n              position: 'before',\n            })\n          }\n          else if (instruction.type === 'reorder-below') {\n            handleReorderNodes({\n              sourceId,\n              targetId,\n              position: 'after',\n            })\n          }\n        }\n      },\n    }),\n  )\n\n  cleanupDnd = dndFunction\n\n  onCleanup(() => {\n    if (dndFunction) {\n      dndFunction()\n    }\n  })\n})\n</script>\n\n<template>\n  <div\n    :class=\"cn('tiptap-tree-structure', props.class)\"\n    data-slot=\"tiptap-structure\"\n  >\n    <div v-if=\"!nodes || nodes.length === 0\" class=\"text-sm text-muted-foreground italic p-2\">\n      No content yet. Start writing to see document structure.\n    </div>\n    <div v-else>\n      <TreeRoot\n        v-slot=\"{ flattenItems }\"\n        class=\"list-none select-none w-full\"\n        :items=\"nodes\"\n        :get-key=\"(item) => item.title\"\n        multiple\n      >\n        <TiptapTreeItem\n          v-for=\"item in flattenItems\"\n          :key=\"item._id + item.index\"\n          :item=\"item\"\n          v-bind=\"item.bind\"\n          @select-node=\"handleSelectNode\"\n          @duplicate-node=\"handleDuplicateNode\"\n          @delete-node=\"handleDeleteNode\"\n        />\n      </TreeRoot>\n    </div>\n  </div>\n</template>\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/tiptap/index.ts",
      "content": "import type { Editor } from '@tiptap/vue-3'\nimport type { ComputedRef, Ref } from 'vue'\nimport { createContext } from 'reka-ui'\n\n// Define the TiptapContext type\nexport interface TiptapContext {\n  editor: ComputedRef<Editor | null>\n  editorNodes: Ref<any[]>\n  sidebarVisible: Ref<boolean>\n  selectedNodeId: Ref<string>\n  toggleSidebar: () => void\n  selectNode: (id: string) => void\n  deleteNode: (id: string) => boolean | void\n  duplicateNode: (id: string) => boolean | void\n  reorderNodes: (params: { sourceId: string, targetId: string, position: 'before' | 'after' }) => boolean | void\n  updateEditorNodes: () => void\n  // Add these missing properties that are used in TiptapProvider.vue\n  canUndo: ComputedRef<boolean>\n  canRedo: ComputedRef<boolean>\n  metadata: ComputedRef<{\n    lastSaved: Date | null\n    wordCount: number\n    charCount: number\n    readingTime: string\n  }>\n  updateMetadata: () => void\n}\n\n// Create context for Tiptap components\nexport const [useTiptapContext, provideTiptapContext]\n  = createContext<TiptapContext>('TiptapEditor')\n\nexport { default as TiptapContent } from './TiptapContent.vue'\n// Export all component parts\nexport { default as TiptapEditor } from './TiptapEditor.vue'\nexport { default as TiptapIcon } from './TiptapIcon.vue'\nexport { default as TiptapKeyboardShortcuts } from './TiptapKeyboardShortcuts.vue'\nexport { default as TiptapMobileToolbar } from './TiptapMobileToolbar.vue'\nexport { default as TiptapProvider } from './TiptapProvider.vue'\nexport { default as TiptapSlotPanel } from './TiptapSlotPanel.vue'\nexport { default as TiptapStatusBar } from './TiptapStatusBar.vue'\nexport { default as TiptapTableToolbar } from './TiptapTableToolbar.vue'\nexport { default as TiptapToolbar } from './TiptapToolbar.vue'\n\nexport { default as TiptapTreeItem } from './TiptapTreeItem.vue'\n// Export the tree-based structure components\nexport { default as TiptapTreeStructure } from './TiptapTreeStructure.vue'\n\n// Re-export utilities\nexport * from './tiptapTreeUtils'\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "ui/tiptap/tiptapTreeUtils.ts",
      "content": "import type { Instruction } from '@atlaskit/pragmatic-drag-and-drop-hitbox/tree-item'\n\nexport interface TiptapTreeItem {\n  title: string\n  name: string\n  icon: string\n  content?: string\n  selected?: boolean\n  depth?: number\n  children?: TiptapTreeItem[]\n}\n\nexport type TiptapTreeAction =\n  | {\n    type: 'instruction'\n    instruction: Instruction\n    itemId: string\n    targetId: string\n  }\n  | {\n    type: 'reorder'\n    sourceId: string\n    targetId: string\n    position: 'before' | 'after'\n  }\n\nexport const tiptapTree = {\n  remove(data: TiptapTreeItem[], id: string): TiptapTreeItem[] {\n    return data\n      .filter(item => item.title !== id)\n      .map((item) => {\n        if (item.children && item.children.length > 0) {\n          return {\n            ...item,\n            children: tiptapTree.remove(item.children, id),\n          }\n        }\n        return item\n      })\n  },\n\n  insertBefore(data: TiptapTreeItem[], targetId: string, newItem: TiptapTreeItem): TiptapTreeItem[] {\n    return data.flatMap((item) => {\n      if (item.title === targetId)\n        return [newItem, item]\n\n      if (item.children && item.children.length > 0) {\n        return {\n          ...item,\n          children: tiptapTree.insertBefore(item.children, targetId, newItem),\n        }\n      }\n      return item\n    })\n  },\n\n  insertAfter(data: TiptapTreeItem[], targetId: string, newItem: TiptapTreeItem): TiptapTreeItem[] {\n    return data.flatMap((item) => {\n      if (item.title === targetId)\n        return [item, newItem]\n\n      if (item.children && item.children.length > 0) {\n        return {\n          ...item,\n          children: tiptapTree.insertAfter(item.children, targetId, newItem),\n        }\n      }\n\n      return item\n    })\n  },\n\n  find(data: TiptapTreeItem[], itemId: string): TiptapTreeItem | undefined {\n    for (const item of data) {\n      if (item.title === itemId)\n        return item\n\n      if (item.children && item.children.length > 0) {\n        const result = tiptapTree.find(item.children, itemId)\n        if (result)\n          return result\n      }\n    }\n\n    return undefined\n  },\n\n  hasChildren(item: TiptapTreeItem): boolean {\n    return Array.isArray(item.children) && item.children.length > 0\n  },\n}\n\nexport function updateTiptapTree(data: TiptapTreeItem[], action: TiptapTreeAction) {\n  if (action.type === 'instruction') {\n    const { instruction, itemId, targetId } = action\n\n    // Find the item that's being moved\n    const item = tiptapTree.find(data, itemId)\n    if (!item)\n      return data\n\n    // Don't allow dropping on itself\n    if (itemId === targetId)\n      return data\n\n    if (instruction.type === 'reorder-above') {\n      let result = tiptapTree.remove(data, itemId)\n      result = tiptapTree.insertBefore(result, targetId, item)\n      return result\n    }\n\n    if (instruction.type === 'reorder-below') {\n      let result = tiptapTree.remove(data, itemId)\n      result = tiptapTree.insertAfter(result, targetId, item)\n      return result\n    }\n  }\n\n  if (action.type === 'reorder') {\n    const { sourceId, targetId, position } = action\n\n    // Find the item that's being moved\n    const item = tiptapTree.find(data, sourceId)\n    if (!item)\n      return data\n\n    // Don't allow dropping on itself\n    if (sourceId === targetId)\n      return data\n\n    // Remove the item from its current position\n    let result = tiptapTree.remove(data, sourceId)\n\n    // Insert at the new position\n    if (position === 'before') {\n      result = tiptapTree.insertBefore(result, targetId, item)\n    }\n    else {\n      result = tiptapTree.insertAfter(result, targetId, item)\n    }\n\n    return result\n  }\n\n  return data\n}\n\n// Helper function to convert flat editor nodes to tree structure\nexport function editorNodesToTree(nodes: any[]): TiptapTreeItem[] {\n  if (!nodes || !Array.isArray(nodes))\n    return []\n\n  return nodes.map(node => ({\n    title: node.id,\n    name: node.name || node.id,\n    icon: node.icon || 'mdi:circle',\n    content: node.content,\n    selected: node.selected,\n    depth: node.depth || 0,\n  }))\n}\n\nexport const shortcuts = [\n  { keys: ['Ctrl', 'B'], description: 'Bold' },\n  { keys: ['Ctrl', 'I'], description: 'Italic' },\n  { keys: ['Ctrl', 'U'], description: 'Underline' },\n  { keys: ['Ctrl', '`'], description: 'Code' },\n  { keys: ['Ctrl', 'Alt', '1-6'], description: 'Heading 1-6' },\n  { keys: ['Ctrl', 'Shift', '8'], description: 'Bullet list' },\n  { keys: ['Ctrl', 'Shift', '9'], description: 'Ordered list' },\n  { keys: ['Tab'], description: 'Indent' },\n  { keys: ['Shift', 'Tab'], description: 'Outdent' },\n  { keys: ['Ctrl', 'Z'], description: 'Undo' },\n  { keys: ['Ctrl', 'Y'], description: 'Redo' },\n]\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}
